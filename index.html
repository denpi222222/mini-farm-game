<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Mini Farm Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #inventory {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      font-family: Arial, sans-serif;
    }
    #inventory ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #inventory li {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="inventory"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/dist/esm/simplex-noise.js"></script>
  <script>
    // Initialize scene, camera, renderer
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xbfd1e5, 0.1, 500); // Add fog for depth perception

    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 50, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Add ambient and directional light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(-100, 100, -100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Noise and constants
    const simplex = new SimplexNoise();
    const CHUNK_SIZE = 16;
    const WORLD_HEIGHT = 81;

    // Block types
    const blockTypes = {
      AIR: 0,
      GRASS: 1,
      DIRT: 2,
      STONE: 3,
      WATER: 4,
      WOOD: 5,
      LEAVES: 6,
      CROPS: 7,
      CROP_STAGE_1: 8,
      CROP_STAGE_2: 9,
      CROP_STAGE_3: 10,
      CROP_STAGE_4: 11,
    };

    // Materials
    const blockMaterials = {
      [blockTypes.GRASS]: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
      [blockTypes.DIRT]: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
      [blockTypes.STONE]: new THREE.MeshLambertMaterial({ color: 0x7f7f7f }),
      [blockTypes.WATER]: new THREE.MeshLambertMaterial({
        color: 0x1ca3ec,
        transparent: true,
        opacity: 0.6,
      }),
      [blockTypes.WOOD]: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
      [blockTypes.LEAVES]: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
      [blockTypes.CROPS]: new THREE.MeshLambertMaterial({
        color: 0xffff00,
        side: THREE.DoubleSide,
      }),
      [blockTypes.CROP_STAGE_1]: new THREE.MeshLambertMaterial({ color: 0x9ACD32 }),
      [blockTypes.CROP_STAGE_2]: new THREE.MeshLambertMaterial({ color: 0x7CFC00 }),
      [blockTypes.CROP_STAGE_3]: new THREE.MeshLambertMaterial({ color: 0x32CD32 }),
      [blockTypes.CROP_STAGE_4]: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
    };

    let chunks = new Map();
    let inventory = {
      seeds: 5,
      crops: 0,
      wood: 0,
    };
    let crops = []; // Array to hold crop objects

    // Generate terrain chunks
    function generateChunk(chunkX, chunkZ) {
      const chunk = new THREE.Group();
      const blockMap = new Map();

      for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
          const worldX = x + chunkX * CHUNK_SIZE;
          const worldZ = z + chunkZ * CHUNK_SIZE;
          const height =
            Math.floor(simplex.noise2D(worldX / 50, worldZ / 50) * 5 + 20);

          for (let y = 0; y < height; y++) {
            let blockType = blockTypes.DIRT;
            if (y === height - 1) blockType = blockTypes.GRASS;
            blockMap.set(`${x},${y},${z}`, blockType);

            const blockGeo = new THREE.BoxGeometry(1, 1, 1);
            const block = new THREE.Mesh(blockGeo, blockMaterials[blockType]);
            block.position.set(worldX, y, worldZ);
            block.receiveShadow = true;
            block.castShadow = true;
            chunk.add(block);
          }
        }
      }

      // Add house at the center chunk
      if (chunkX === 0 && chunkZ === 0) buildHouse(chunk);

      chunks.set(`${chunkX},${chunkZ}`, { chunk, blockMap });
      scene.add(chunk);
    }

    // Build a simple house
    function buildHouse(chunk) {
      const house = new THREE.Group();

      // Walls
      const wallGeo = new THREE.BoxGeometry(1, 1, 1);
      for (let x = -2; x <= 2; x++) {
        for (let y = 0; y < 3; y++) {
          for (let z = -2; z <= 2; z++) {
            if (x === -2 || x === 2 || z === -2 || z === 2) {
              if (!(x === 0 && z === -2 && y < 2)) { // Door space
                const block = new THREE.Mesh(wallGeo, blockMaterials[blockTypes.WOOD]);
                block.position.set(x, y + 20, z);
                block.castShadow = true;
                block.receiveShadow = true;
                house.add(block);
              }
            }
          }
        }
      }

      // Roof
      const roofGeo = new THREE.ConeGeometry(3.5, 1, 4);
      const roof = new THREE.Mesh(roofGeo, blockMaterials[blockTypes.WOOD]);
      roof.position.set(0, 23.5, 0);
      roof.rotation.y = Math.PI / 4;
      roof.castShadow = true;
      house.add(roof);

      chunk.add(house);
    }

    // Update inventory display
    function updateInventoryDisplay() {
      const inventoryDiv = document.getElementById('inventory');
      inventoryDiv.innerHTML = '<strong>Inventory:</strong><ul>';
      for (const [item, count] of Object.entries(inventory)) {
        inventoryDiv.innerHTML += `<li>${item}: ${count}</li>`;
      }
      inventoryDiv.innerHTML += '</ul>';
    }

    // Load visible chunks
    function loadVisibleChunks(playerX, playerZ) {
      const chunkX = Math.floor(playerX / CHUNK_SIZE);
      const chunkZ = Math.floor(playerZ / CHUNK_SIZE);

      for (let x = chunkX - 1; x <= chunkX + 1; x++) {
        for (let z = chunkZ - 1; z <= chunkZ + 1; z++) {
          if (!chunks.has(`${x},${z}`)) {
            generateChunk(x, z);
          }
        }
      }
    }

    // Player setup
    const keys = {};
    const clock = new THREE.Clock();

    const player = {
      velocity: new THREE.Vector3(),
      height: 2,
      moveSpeed: 10,
      jumpSpeed: 15,
      gravity: -30,
      canJump: false,
      onGround: false,
      position: new THREE.Vector3(0, 50, 0),
    };

    // Movement handling
    function handleMovement(delta) {
      const moveDir = new THREE.Vector3();
      if (keys['w']) moveDir.z -= 1;
      if (keys['s']) moveDir.z += 1;
      if (keys['a']) moveDir.x -= 1;
      if (keys['d']) moveDir.x += 1;
      moveDir.normalize();

      // Apply movement
      const angle = camera.rotation.y;
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      player.velocity.x = (moveDir.x * cos - moveDir.z * sin) * player.moveSpeed;
      player.velocity.z = (moveDir.z * cos + moveDir.x * sin) * player.moveSpeed;

      // Apply gravity
      if (!player.onGround) {
        player.velocity.y += player.gravity * delta;
      }

      // Update position
      const deltaPosition = player.velocity.clone().multiplyScalar(delta);
      player.position.add(deltaPosition);

      // Simple ground collision
      if (player.position.y <= 21) {
        player.position.y = 21;
        player.velocity.y = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // Update camera
      camera.position.copy(player.position).add(new THREE.Vector3(0, player.height, 0));
    }

    // Plant crops
    function plantCrop() {
      if (inventory.seeds > 0) {
        const crop = {
          mesh: createCropMesh(),
          growthStage: 0,
          position: new THREE.Vector3(
            Math.round(player.position.x),
            21.5,
            Math.round(player.position.z)
          ),
          growthTime: 0,
        };
        crop.mesh.position.copy(crop.position);
        scene.add(crop.mesh);
        crops.push(crop);

        inventory.seeds -= 1;
        updateInventoryDisplay();
      }
    }

    // Create crop mesh
    function createCropMesh() {
      const cropGeo = new THREE.PlaneGeometry(0.5, 0.5);
      const cropMesh = new THREE.Mesh(cropGeo, blockMaterials[blockTypes.CROP_STAGE_1]);
      cropMesh.rotation.x = -Math.PI / 2;
      cropMesh.receiveShadow = true;
      return cropMesh;
    }

    // Harvest crops
    function harvestCrop(cropIndex) {
      const crop = crops[cropIndex];
      scene.remove(crop.mesh);
      crops.splice(cropIndex, 1);
      inventory.crops += 1;
      updateInventoryDisplay();
    }

    // Animate crops (grow over time)
    function animateCrops(delta) {
      for (let i = crops.length - 1; i >= 0; i--) {
        const crop = crops[i];
        crop.growthTime += delta;
        if (crop.growthTime >= 5 && crop.growthStage < 4) {
          crop.growthStage += 1;
          crop.growthTime = 0;
          crop.mesh.material = blockMaterials[blockTypes[`CROP_STAGE_${crop.growthStage}`]];
        }
        // If fully grown, allow harvesting
        if (crop.growthStage === 4) {
          const distance = player.position.distanceTo(crop.position);
          if (distance < 2 && keys['f']) {
            harvestCrop(i);
          }
        }
      }
    }

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      loadVisibleChunks(player.position.x, player.position.z);
      handleMovement(delta);
      animateCrops(delta);

      renderer.render(scene, camera);
    }

    // Event listeners
    window.addEventListener('keydown', (event) => {
      keys[event.key.toLowerCase()] = true;

      // Jump
      if (event.key === ' ' && player.onGround) {
        player.velocity.y = player.jumpSpeed;
        player.onGround = false;
      }

      // Plant crop
      if (event.key.toLowerCase() === 'e') {
        plantCrop();
      }
    });

    window.addEventListener('keyup', (event) => {
      keys[event.key.toLowerCase()] = false;
    });

    // Mouse controls
    let isMouseDown = false;
    let prevMouseX = 0;

    renderer.domElement.addEventListener('mousedown', (event) => {
      isMouseDown = true;
      prevMouseX = event.clientX;
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    renderer.domElement.addEventListener('mousemove', (event) => {
      if (isMouseDown) {
        const deltaX = event.clientX - prevMouseX;
        camera.rotation.y -= deltaX * 0.002;
        prevMouseX = event.clientX;
      }
    });

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateInventoryDisplay();
    animate();
  </script>
</body>
</html>
