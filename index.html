<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Улучшенная Мини Ферма</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #inventory {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      font-family: Arial, sans-serif;
    }
    #inventory ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #inventory li {
      margin: 5px 0;
    }
    #day-night {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="inventory"></div>
  <div id="day-night"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/simplex-noise.umd.js"></script>
  <script>
    // Инициализация сцены, камеры и рендера
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 25, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Добавление света
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(-100, 100, -100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Добавление земли
    const groundGeo = new THREE.PlaneGeometry(1000, 1000);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Константы и переменные
    const simplex = new SimplexNoise();
    const CHUNK_SIZE = 16;

    // Типы блоков
    const blockTypes = {
      GRASS: 1,
      DIRT: 2,
      WOOD: 5,
      CROP_STAGE_1: 8,
      CROP_STAGE_2: 9,
      CROP_STAGE_3: 10,
      CROP_STAGE_4: 11,
    };

    // Материалы
    const blockMaterials = {
      [blockTypes.GRASS]: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
      [blockTypes.DIRT]: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
      [blockTypes.WOOD]: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
      [blockTypes.CROP_STAGE_1]: new THREE.MeshLambertMaterial({ color: 0x9ACD32 }),
      [blockTypes.CROP_STAGE_2]: new THREE.MeshLambertMaterial({ color: 0x7CFC00 }),
      [blockTypes.CROP_STAGE_3]: new THREE.MeshLambertMaterial({ color: 0x32CD32 }),
      [blockTypes.CROP_STAGE_4]: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
    };

    let chunks = new Map();
    let inventory = {
      seeds: 5,
      crops: 0,
    };
    let crops = [];

    // Генерация чанков
    function generateChunk(chunkX, chunkZ) {
      const chunk = new THREE.Group();

      for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
          const worldX = x + chunkX * CHUNK_SIZE;
          const worldZ = z + chunkZ * CHUNK_SIZE;
          const height = 1; // Плоская земля

          const blockGeo = new THREE.BoxGeometry(1, 1, 1);
          const block = new THREE.Mesh(blockGeo, blockMaterials[blockTypes.GRASS]);
          block.position.set(worldX, 0, worldZ);
          block.receiveShadow = true;
          block.castShadow = true;
          chunk.add(block);
        }
      }

      // Добавление дома в центре
      if (chunkX === 0 && chunkZ === 0) buildHouse(chunk);

      chunks.set(`${chunkX},${chunkZ}`, chunk);
      scene.add(chunk);
    }

    // Построение дома
    function buildHouse(chunk) {
      const house = new THREE.Group();

      // Стены
      const wallGeo = new THREE.BoxGeometry(1, 1, 1);
      for (let x = -2; x <= 2; x++) {
        for (let y = 0; y < 3; y++) {
          for (let z = -2; z <= 2; z++) {
            if (x === -2 || x === 2 || z === -2 || z === 2) {
              if (!(x === 0 && z === -2 && y < 2)) {
                const block = new THREE.Mesh(wallGeo, blockMaterials[blockTypes.WOOD]);
                block.position.set(x, y + 1, z);
                block.castShadow = true;
                block.receiveShadow = true;
                house.add(block);
              }
            }
          }
        }
      }

      // Крыша
      const roofGeo = new THREE.ConeGeometry(3.5, 1, 4);
      const roof = new THREE.Mesh(roofGeo, blockMaterials[blockTypes.WOOD]);
      roof.position.set(0, 4, 0);
      roof.rotation.y = Math.PI / 4;
      roof.castShadow = true;
      house.add(roof);

      house.position.set(0, 0, 0);
      chunk.add(house);
    }

    // Обновление инвентаря
    function updateInventoryDisplay() {
      const inventoryDiv = document.getElementById('inventory');
      inventoryDiv.innerHTML = '<strong>Инвентарь:</strong><ul>';
      for (const [item, count] of Object.entries(inventory)) {
        inventoryDiv.innerHTML += `<li>${item}: ${count}</li>`;
      }
      inventoryDiv.innerHTML += '</ul>';
    }

    // Загрузка видимых чанков
    function loadVisibleChunks(playerX, playerZ) {
      const chunkX = Math.floor(playerX / CHUNK_SIZE);
      const chunkZ = Math.floor(playerZ / CHUNK_SIZE);

      for (let x = chunkX - 1; x <= chunkX + 1; x++) {
        for (let z = chunkZ - 1; z <= chunkZ + 1; z++) {
          if (!chunks.has(`${x},${z}`)) {
            generateChunk(x, z);
          }
        }
      }
    }

    // Настройка игрока
    const keys = {};
    const clock = new THREE.Clock();

    const player = {
      velocity: new THREE.Vector3(),
      height: 2,
      moveSpeed: 10,
      jumpSpeed: 15,
      gravity: -30,
      canJump: false,
      onGround: false,
      position: new THREE.Vector3(0, 2, 10),
    };

    // Обработка движения
    function handleMovement(delta) {
      const moveDir = new THREE.Vector3();
      if (keys['w']) moveDir.z -= 1;
      if (keys['s']) moveDir.z += 1;
      if (keys['a']) moveDir.x -= 1;
      if (keys['d']) moveDir.x += 1;
      moveDir.normalize();

      const angle = camera.rotation.y;
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      player.velocity.x = (moveDir.x * cos - moveDir.z * sin) * player.moveSpeed;
      player.velocity.z = (moveDir.z * cos + moveDir.x * sin) * player.moveSpeed;

      if (!player.onGround) {
        player.velocity.y += player.gravity * delta;
      }

      const deltaPosition = player.velocity.clone().multiplyScalar(delta);
      player.position.add(deltaPosition);

      if (player.position.y <= 2) {
        player.position.y = 2;
        player.velocity.y = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      camera.position.copy(player.position).add(new THREE.Vector3(0, player.height, 0));

      // Ограничение угла обзора по вертикали
      camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
    }

    // Посадка культур
    function plantCrop() {
      if (inventory.seeds > 0) {
        const crop = {
          mesh: createCropMesh(),
          growthStage: 1,
          position: new THREE.Vector3(
            Math.round(player.position.x),
            1.5,
            Math.round(player.position.z)
          ),
          growthTime: 0,
        };
        crop.mesh.position.copy(crop.position);
        scene.add(crop.mesh);
        crops.push(crop);

        inventory.seeds -= 1;
        updateInventoryDisplay();
      }
    }

    // Создание меша культуры
    function createCropMesh() {
      const cropGeo = new THREE.PlaneGeometry(0.5, 0.5);
      const cropMesh = new THREE.Mesh(cropGeo, blockMaterials[blockTypes.CROP_STAGE_1]);
      cropMesh.rotation.x = -Math.PI / 2;
      cropMesh.receiveShadow = true;
      return cropMesh;
    }

    // Сбор урожая
    function harvestCrop(cropIndex) {
      const crop = crops[cropIndex];
      scene.remove(crop.mesh);
      crops.splice(cropIndex, 1);
      inventory.crops += 1;
      updateInventoryDisplay();
    }

    // Анимация роста культур
    function animateCrops(delta) {
      for (let i = crops.length - 1; i >= 0; i--) {
        const crop = crops[i];
        crop.growthTime += delta;
        if (crop.growthTime >= 5 && crop.growthStage < 4) {
          crop.growthStage += 1;
          crop.growthTime = 0;
          crop.mesh.material = blockMaterials[blockTypes[`CROP_STAGE_${crop.growthStage}`]];
        }
        if (crop.growthStage === 4) {
          const distance = player.position.distanceTo(crop.position);
          if (distance < 2 && keys['f']) {
            harvestCrop(i);
          }
        }
      }
    }

    // Смена дня и ночи
    let time = 0;
    function updateDayNightCycle(delta) {
      time += delta;
      const dayNightDiv = document.getElementById('day-night');
      const isDay = (Math.floor(time) % 20) < 10;
      ambientLight.intensity = isDay ? 0.8 : 0.2;
      dayNightDiv.innerText = isDay ? 'День' : 'Ночь';
    }

    // Главный цикл анимации
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      loadVisibleChunks(player.position.x, player.position.z);
      handleMovement(delta);
      animateCrops(delta);
      updateDayNightCycle(delta);

      renderer.render(scene, camera);
    }

    // Обработчики событий
    window.addEventListener('keydown', (event) => {
      keys[event.key.toLowerCase()] = true;

      if (event.key === ' ' && player.onGround) {
        player.velocity.y = player.jumpSpeed;
        player.onGround = false;
      }

      if (event.key.toLowerCase() === 'e') {
        plantCrop();
      }
    });

    window.addEventListener('keyup', (event) => {
      keys[event.key.toLowerCase()] = false;
    });

    // Управление мышью
    let isMouseDown = false;
    let prevMouseX = 0;
    let prevMouseY = 0;

    renderer.domElement.addEventListener('mousedown', (event) => {
      isMouseDown = true;
      prevMouseX = event.clientX;
      prevMouseY = event.clientY;
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    renderer.domElement.addEventListener('mousemove', (event) => {
      if (isMouseDown) {
        const deltaX = event.clientX - prevMouseX;
        const deltaY = event.clientY - prevMouseY;
        camera.rotation.y -= deltaX * 0.002;
        camera.rotation.x -= deltaY * 0.002;
        prevMouseX = event.clientX;
        prevMouseY = event.clientY;
      }
    });

    // Обработка изменения размера окна
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateInventoryDisplay();
    animate();
  </script>
</body>
</html>
